// Generated by CoffeeScript 2.6.1
(function() {
  // The **Scope** class regulates lexical scoping within CoffeeScript. As you
  // generate code, you create a tree of scopes in the same shape as the nested
  // function bodies. Each scope knows about the variables declared within it,
  // and has a reference to its parent enclosing scope. In this way, we know which
  // variables are new and need to be declared with `var`, and which are shared
  // with external scopes.
  var Scope,
    indexOf = [].indexOf;

  exports.Scope = Scope = class Scope {
    // Initialize a scope with its parent, for lookups up the chain,
    // as well as a reference to the **Block** node it belongs to, which is
    // where it should declare its variables, a reference to the function that
    // it belongs to, and a list of variables referenced in the source code
    // and therefore should be avoided when generating variables. Also track comments
    // that should be output as part of variable declarations.
    constructor(parent, expressions, method, referencedVars) {
      var ref, ref1;
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.referencedVars = referencedVars;
      this.variables = [
        {
          name: 'arguments',
          type: 'arguments'
        }
      ];
      this.positions = {};
      if (!this.parent) {
        this.utilities = {};
      }
      // The `@root` is the top-level **Scope** object for a given file.
      this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
    }

    // Adds a new variable or overrides an existing one.
    add(name, type, immediate) {
      var variable;
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (variable = this.get(name)) {
        return variable.type = type;
      } else {
        return this.positions[name] = this.variables.push({name, type}) - 1;
      }
    }

    // When `super` is called, we need to find the name of the current method we're
    // in, so that we know how to invoke the same method of the parent class. This
    // can get complicated if super is being called from an inner function.
    // `namedMethod` will walk up the scope tree until it either finds the first
    // function object that has a name filled in, or bottoms out.
    namedMethod() {
      var ref;
      if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    }

    // Look up a variable name in lexical scope, and declare it if it does not
    // already exist.
    find(name, type = 'var') {
      if (this.check(name)) {
        return true;
      }
      this.add(name, type);
      return false;
    }

    // Reserve a variable name as originating from a function parameter for this
    // scope. No `var` required for internal references.
    parameter(name) {
      if (this.shared && this.parent.check(name)) {
        return;
      }
      return this.add(name, 'param', true);
    }

    // Just check to see if a variable has already been declared, without reserving,
    // walks up to the root scope.
    check(name) {
      var ref;
      return (this.get(name) != null) || ((ref = this.parent) != null ? ref.check(name) : void 0);
    }

    // Generate a temporary variable name at the given index.
    temporary(name, index, single = false) {
      if (single) {
        var startCode = name.charCodeAt(0);
        var endCode = 'z'.charCodeAt(0);
        var diff = endCode - startCode;
        var newCode = startCode + index % (diff + 1);
        var letter = String.fromCharCode(newCode);
        var num = Math.floor(index / (diff + 1));
        return `${letter}${num || ''}`;
      } else {
        return `${name}${index || ''}`;
      }
    }

    // Gets a variable and its associated data from this scope (not ancestors),
    // or `undefined` if it doesn't exist.
    get(name) {
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]];
      }
    }

    // Gets the type of a variable declared in this scope,
    // or `undefined` if it doesn't exist.
    type(name) {
      var ref;
      return (ref = this.get(name)) != null ? ref.type : void 0;
    }

    // If we need to store an intermediate result, find an available name for a
    // compiler-generated variable. `_var`, `_var2`, and so on...
    freeVariable(name, options = {}) {
      var ref;
      var index = 0;
      while (true) {
        var temp = this.temporary(name, index, options.single);
        if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
          break;
        }
        index++;
      }
      if ((ref = options.reserve) != null ? ref : true) {
        this.add(temp, 'var', true);
      }
      if (options.laterVar) {
        this.laterVar(temp);
      }
      return temp;
    }

    // Ensure that an assignment is made at the top of this scope.
    assign(name, value) {
      return this.get(name).assigned = value;
    }

    // Add a comment that should appear when the variable is declared
    // (for Flow support).
    comment(name, comments) {
      return this.get(name).comments = comments;
    }

    // Does this variable have a comment attached to it in this scope?
    hasComment(name) {
      var ref;
      return ((ref = this.get(name)) != null ? ref.comments : void 0) != null;
    }

    // Check whether a var declaration of this variable could go later, and if so,
    // mark it as so.
    laterVar(name) {
      // Ensure variable is declared at this scope, as a regular 'var', and
      // we haven't already given it a var prefix somewhere, and it doesn't
      // have an attachment that goes with a top var declaration.
      var v = this.get(name);
      var later = (v != null ? v.type : void 0) === 'var' && !(v.laterVar || (v.comments != null));
      if (later) {
        v.laterVar = true;
      }
      return later;
    }

    // Does this scope have any declared variables?
    hasDeclarations() {
      var ref = this.variables;
      for (var j = 0, len = ref.length; j < len; j++) {
        var v = ref[j];
        if (v.type === 'var' && !v.laterVar) {
          return true;
        }
      }
    }

    // Return a list of names of variables declared in this scope.
    // Optionally restrict to assigned or unassigned variables.
    declaredVariables(assigned) {
      var v;
      return ((function() {
        var ref = this.variables;
        var results = [];
        for (var j = 0, len = ref.length; j < len; j++) {
          v = ref[j];
          if (v.type === 'var' && !v.laterVar && (function() {
            switch (assigned) {
              case true:
                return v.assigned != null;
              case false:
                return v.assigned == null;
              default:
                return true;
            }
          })()) {
            results.push(v.name);
          }
        }
        return results;
      }).call(this)).sort();
    }

    // Extract all variables from `start` onward.
    spliceVariables(start) {
      for (var ref = start, j = ref, i = j, ref1 = this.variables.length; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
        delete this.positions[this.variables[i]];
      }
      return this.variables.splice(start);
    }

    // Add variables to this scope, e.g. as returned from `spliceVariables`.
    addVariables(vars) {
      var results = [];
      for (var j = 0, len = vars.length; j < len; j++) {
        var v = vars[j];
        results.push(this.positions[v.name] = this.variables.push(v) - 1);
      }
      return results;
    }

  };

}).call(this);
